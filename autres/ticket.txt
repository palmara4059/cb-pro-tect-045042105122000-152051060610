const fs = require('fs');
const { Client, Collection, Intents, MessageEmbed, MessageActionRow, MessageButton, Collector } = require('discord.js');
const { token } = require('./config.json');

const client = new Client({ partials: ['GUILD_MEMBER', 'USER', 'MESSAGE', 'CHANNEL', 'REACTION'], intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MEMBERS, Intents.FLAGS.GUILD_BANS, Intents.FLAGS.GUILD_EMOJIS_AND_STICKERS, Intents.FLAGS.GUILD_INTEGRATIONS, Intents.FLAGS.GUILD_WEBHOOKS, Intents.FLAGS.GUILD_INVITES, Intents.FLAGS.GUILD_VOICE_STATES, Intents.FLAGS.GUILD_PRESENCES, Intents.FLAGS.GUILD_MESSAGES, Intents.FLAGS.GUILD_MESSAGE_REACTIONS, Intents.FLAGS.GUILD_MESSAGE_TYPING, Intents.FLAGS.DIRECT_MESSAGES, Intents.FLAGS.DIRECT_MESSAGE_REACTIONS, Intents.FLAGS.DIRECT_MESSAGE_TYPING, Intents.FLAGS.GUILD_SCHEDULED_EVENTS], allowedMentions: { parse: ['users', 'roles'], repliedUser: true } });
["commands"].forEach(x => client[x] = new Collection());
const { loadEvents, loadSlashCommands } = require("./utils/loader.js");
require('./utils/functions')(client)
loadEvents(client);
loadSlashCommands(client);

const eventFiles = fs.readdirSync('./events').filter(file => file.endsWith('.js'));

for (const file of eventFiles) {
	const event = require(`./events/${file}`);
	if (event.once) {
		client.once(event.name, (...args) => event.execute(...args));
	} else {
		client.on(event.name, (...args) => event.execute(...args));
	}
}

client.on('interactionCreate', async interaction => {
	if (interaction.isButton()) { client.emit('clickButton', interaction); };
	if (!interaction.isCommand()) return;
	const command = client.commands.get(interaction.commandName);
	if (!command) return;
	try {
		await command.execute(client, interaction);
	} catch (error) {
		console.error(error);
		await interaction.reply({ content: "Une erreur s'est produite lors de l'ex√©cution de cette commande !", ephemeral: true });
	}
});

client.on('clickButton', async button => {
	if (button.customId === "ticketHelp") {
		const categoryTicket = button.guild.channels.cache.find(r => r.name === "üÜò ¬ª support");
		const logTicket = button.guild.channels.cache.find(c => c.name === "üíæ„Éªtickets-logs");

		if(!categoryTicket) {
			return button.guild.channels.create("üÜò ¬ª support", { type: "GUILD_CATEGORY" });
		}
		if(!logTicket) {
			return button.guild.channels.create("üíæ„Éªtickets-logs");
		}

		if (client.guilds.cache.get(button.guildId).channels.cache.find(c => c.topic == button.user.id)) {
			return button.reply({
			  content: `Vous avez d√©j√† cr√©√© un ticket (ticket-${button.user.username})!`,
			  ephemeral: true
			});
		}
		button.guild.channels.create(`ticket-${button.user.username}`, {
			parent: categoryTicket,
			topic: button.user.id,
			permissionOverwrites: [{
				id: button.user.id,
				allow: ['SEND_MESSAGES', 'VIEW_CHANNEL'],
			  },
			  {
				id: button.guild.roles.everyone,
				deny: ['VIEW_CHANNEL'],
			  },
			],
			type: 'text',
		  }).then(channel => {
			const row = new MessageActionRow().addComponents(new MessageButton().setCustomId('ticketClose').setLabel('üîí cl√¥turer mon ticket').setStyle('SECONDARY'),);
			const openTicket = new MessageEmbed().setColor('#202225').setTitle("Bienvenue sur ton ticket !").setDescription(`Notre √©quipe arrive tr√®s prochainement,\n en attendant merci de nous d√©tailler ton probl√®me.\n\n si tu souhaite ajouter un membre utilise la commande \`/addmembers\`\nLe membre doit √™tre pr√©sent sur le serveur.`)
			channel.send({ embeds: [openTicket], components: [row], content: `<@${button.user.id}>` })
		})
		button.reply({
			content: `Votre ticket √† √©t√© cr√©er sous le nom de (ticket-${button.user.username})!`,
			ephemeral: true
		  });
    }

	if (button.customId === "ticketClose") {
		button.channel.delete()
		const catSupport = button.guild.channels.cache.find(channel => channel.name === "üíæ„Éªtickets-logs");
		const closeTicket = new MessageEmbed().setColor('#202225').setTitle("Ticket fermer !").setDescription(`le ticket (\`${button.channel.name}\`) √† √©t√© fermer.`).addField("Ticket fermer par :", `${button.user.tag}\nid :\`${button.user.id}\``, true)
		catSupport.send({ embeds: [closeTicket]})
	}

	if (button.customId === "verifPast") {
		const member = button.member;
		role = button.guild.roles.cache.find(r => r.name === "Membre v√©rifi√©");
		member.roles.add(role);
		button.reply({ content: 'F√©licitions, tu as √©t√© v√©rifi√© avec succ√®s !', ephemeral: true });
	}
})

client.login(token);